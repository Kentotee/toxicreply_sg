<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTO or Not Test</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            overflow-y: hidden; /* Prevent body scroll */
        }
        .app-container {
            display: flex;
            flex-direction: column;
            width: 100vw;
            height: 100vh;
            background-color: white;
        }
        .chat-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 16px;
            scroll-behavior: smooth;
        }
        .message-bubble {
            max-width: 85%;
            padding: 10px 14px;
            border-radius: 18px;
            margin-bottom: 12px;
            word-wrap: break-word;
            font-size: 15px;
        }
        /* User's input (Partner's message in game) - now left, gray */
        .user-input-bubble {
            background-color: #e5e7eb; /* Light Gray */
            color: #1f2937;
            align-self: flex-start;
            border-bottom-left-radius: 4px;
            margin-right: auto;
        }
        /* AI's reply (Your message in game) - now right, blue */
        .ai-reply-bubble {
            background-color: #3b82f6; /* Blue */
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
            margin-left: auto;
        }
        .coach-bubble {
            background-color: #fce7f3; /* Pink */
            color: #9d174d; /* Dark Pink */
            text-align: center;
            border-radius: 8px;
            margin: 0 auto 12px;
            max-width: 90%;
        }
    </style>
</head>
<body>

    <div id="app" class="app-container">

        
        <div class="pt-4 pb-4 px-4 bg-white border-b border-gray-200 sticky top-0 z-10">
            <div class="flex items-center justify-between">
                <h1 class="text-2xl font-extrabold text-green-600">BTO or Not Test</h1>
                
                <div class="flex items-center space-x-2">
                    <span id="milestone-emoji" class="text-2xl">🌳</span> 
                    <span id="display-streak" class="text-xl font-bold text-green-700">0 / 25</span>
                </div>
                <div class="flex items-center space-x-3">
                    
                    <select id="casing-select" class="p-2 border border-gray-300 rounded-lg text-sm font-medium focus:ring-green-500 focus:border-green-500">
                        <option value="millennial">Millennial Case</option>
                        <option value="genz">Gen Z Case</option>
                    </select>

                    
                    <button id="restart-button" class="px-3 py-2 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 transition duration-150 text-sm">
                        Restart
                    </button>
                </div>
            </div>

            
            <div class="mt-4 relative h-3 bg-gray-200 rounded-full overflow-hidden">
                <div id="progress-bar" class="h-full bg-green-500 transition-all duration-500 ease-out" style="width: 0%;"></div>
            </div>
        </div>
        
        
        <div id="chat-window" class="chat-container flex flex-col">
            
            <div class="message-bubble coach-bubble">
                Enter your partner's message
            </div>
            
        </div>

        
        <div class="p-4 border-t border-gray-200 bg-white sticky bottom-0">
            <div id="loading-indicator" class="hidden text-sm text-gray-500 mb-2 text-center">
                <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-green-500 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Partner is typing...
            </div>
            
            <div class="flex space-x-2">
                <input type="text" id="user-input" placeholder="Enter your partner's reply..." 
                       class="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                <button id="send-button" 
                        class="p-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition duration-150">
                    Send
                </button>
            </div>
            
            <div id="message-box" class="p-2 text-center text-sm rounded-lg mt-2 hidden" role="alert"></div>
        </div>
        
    </div>

    
    <script type="module">
        // Firebase imports are not strictly needed for this chat sim, but included for environment compatibility
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Suppress console spam from auth
        setLogLevel('Error');

        // Environment variables (used for initialization boilerplate)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        const apiKey = ""; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        // DOM Elements
        const chatWindow = document.getElementById('chat-window');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const loadingIndicator = document.getElementById('loading-indicator');
        const messageBox = document.getElementById('message-box');
        const restartButton = document.getElementById('restart-button');
        const progressBar = document.getElementById('progress-bar');
        const casingSelect = document.getElementById('casing-select');
        const displayStreakElement = document.getElementById('display-streak');
        const milestoneEmojiElement = document.getElementById('milestone-emoji'); 

        // Game State
        let currentStreak = 0;
        let chatLog = []; // Stores LLM history (role: text)
        let lastModelMessages = []; // Stores only the text of the last N model replies to prevent repetition
        const MAX_LOG_SIZE = 10;
        const MAX_MODEL_MESSAGES = 10;
        const MAX_STREAK = 25; // The maximum streak for the progress bar

        // Milestone Emojis
        const MILESTONE_EMOJIS = {
            0: '🌳', // Default (Green Tree)
            5: '🤝',
            7: '💋',
            10: '💒',
            12: '🏠',
            15: '👨‍👩‍👧',
            17: '👨‍👩‍👧‍👦',
            20: '👅',
            25: '💦'
        };
        
        // Singapore-Specific Jokes (4 will be randomly selected)
        const SINGAPORE_JOKES = [
            "If this streak don't pass, we can eat at Lau Pa Sat for his/her birthday.",
            "Want BTO but with this kind of patience? Forget it.",
            "Aiyah, already talk so much also never solve, better go queue for $2.50 mala at the hawker centre.",
            "This relationship more dramatic than NDP performance, steady lah.",
            "This much drama, sure BTO flat price increase next year.",
            "Your partner's patience level lower than COE prices in 1990.",
            "Don't worry, even if the BTO fail, you can still ballot for resale in Punggol.",
            "This kind of arguing better than finding parking at Orchard on a Saturday."
        ];
        let jokeSchedule = {}; // Stores { streakNumber: "Joke Text", ... }

        // --- Joke Setup Function ---
        const setupJokeSchedule = () => {
            jokeSchedule = {};
            const jokeStreaks = new Set();
            const jokeCount = 4;
            const availableStreaks = [];
            
            // Generate pool of streaks (1 to 25)
            for (let i = 1; i <= MAX_STREAK; i++) {
                availableStreaks.push(i);
            }
            
            // Select 4 unique random streaks
            while (jokeStreaks.size < jokeCount && availableStreaks.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableStreaks.length);
                const selectedStreak = availableStreaks.splice(randomIndex, 1)[0];
                jokeStreaks.add(selectedStreak);
            }

            const selectedStreaksArray = Array.from(jokeStreaks).sort((a, b) => a - b);
            
            // Assign unique jokes to the selected streaks
            const shuffledJokes = SINGAPORE_JOKES.sort(() => 0.5 - Math.random());
            
            selectedStreaksArray.forEach((streak, index) => {
                if (shuffledJokes[index]) {
                    jokeSchedule[streak] = shuffledJokes[index];
                }
            });
        };

        // --- Utility & UI Functions ---

        const showMessage = (text, type = 'error') => {
            messageBox.textContent = text;
            messageBox.className = 'p-2 text-center text-sm rounded-lg mt-2 ' + (type === 'error' ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700');
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 5000);
        };

        const updateProgressBar = () => {
            const percentage = Math.min(100, (currentStreak / MAX_STREAK) * 100);
            progressBar.style.width = `${percentage}%`;
            
            // Update the visible streak number (X / 25)
            if (displayStreakElement) {
                displayStreakElement.textContent = `${currentStreak} / ${MAX_STREAK}`;
            }

            // Update milestone emoji
            if (milestoneEmojiElement) {
                let currentEmoji = MILESTONE_EMOJIS[0]; // Default
                for (const streak in MILESTONE_EMOJIS) {
                    if (currentStreak >= parseInt(streak)) {
                        currentEmoji = MILESTONE_EMOJIS[streak];
                    }
                }
                milestoneEmojiElement.textContent = currentEmoji;
            }
        };

        const appendMessage = (text, sender) => {
            // isMyMessage (AI generated reply) -> right/blue (ai-reply-bubble)
            // isPartnersMessage (User input) -> left/gray (user-input-bubble)
            const isMyMessage = sender === 'my-message'; // My message (AI generated)
            const isPartnersMessage = sender === 'partner-message'; // Partner's message (User input)
            const isCoach = sender === 'coach'; 

            const bubble = document.createElement('div');
            bubble.className = `message-bubble ${isCoach ? 'coach-bubble' : (isMyMessage ? 'ai-reply-bubble' : 'user-input-bubble')}`;
            bubble.textContent = text;
            
            const wrapper = document.createElement('div');
            wrapper.className = 'flex ' + (isMyMessage ? 'justify-end' : 'justify-start');
            if (isCoach) {
                wrapper.className = 'flex justify-center';
            }
            
            wrapper.appendChild(bubble); // Append bubble to wrapper
            chatWindow.appendChild(wrapper); // Append wrapper to chat window
            
            // Scroll to the bottom
            chatWindow.scrollTop = chatWindow.scrollHeight;
            
            // Add to history (LLM format) only if it's user or model
            if (isPartnersMessage || isMyMessage) {
                chatLog.push({ 
                    role: isPartnersMessage ? "user" : "model", // LLM perspective: user is the partner, model is the AI
                    parts: [{ text: text }] 
                });
            }

            // If it's the model's reply (my-message), store it for the uniqueness check
            if (isMyMessage) {
                lastModelMessages.push(text.trim());
                if (lastModelMessages.length > MAX_MODEL_MESSAGES) {
                    lastModelMessages.shift(); // Keep only the latest N messages
                }
            }

            // Trim chatLog history for context
            if (chatLog.length > MAX_LOG_SIZE) {
                chatLog = chatLog.slice(chatLog.length - MAX_LOG_SIZE);
            }
        };

        // --- Game Logic ---

        const restartGame = () => {
            currentStreak = 0;
            chatLog = [];
            lastModelMessages = [];
            chatWindow.innerHTML = `
                <div class="message-bubble coach-bubble">
                    Enter your partner's message
                </div>
            `;
            setupJokeSchedule(); // Recalculate joke streaks
            updateProgressBar();
            showMessage("Challenge restarted! Good luck!", 'success');
            userInput.disabled = false;
            sendButton.disabled = false;
            userInput.focus();
        };

        const endGame = (reason) => {
            const finalMessage = reason || "The conversation ended.";
            userInput.disabled = true;
            sendButton.disabled = true;
            appendMessage(finalMessage, 'coach');
            showMessage(`BTO or Not Test Failed! Final Score: ${currentStreak} / ${MAX_STREAK}`, 'error');
        };
        
        const getSystemInstruction = () => {
            const casing = casingSelect.value;
            let casingInstruction;
            
            if (casing === 'genz') {
                casingInstruction = "3. **Casing & Grammar:** Use minimal punctuation, excessive lowercase (gen z style), and common texting abbreviations (ikr, lol, fr, kinda). Use typos occasionally.";
            } else { // millennial
                casingInstruction = "3. **Casing & Grammar:** Use proper casing and standard punctuation, sounding like a typical older millennial text message.";
            }

            const uniqueConstraint = lastModelMessages.length > 0
                ? `4. **Uniqueness Check (CRITICAL):** The reply MUST be unique. DO NOT repeat any of these phrases from the current streak: [${lastModelMessages.join('; ')}]. If you cannot generate a unique reply, generate a short, extremely dismissive one like 'stop being so extra'.`
                : "4. **Uniqueness Check:** Ensure the reply is creative and unique.";


            // Difficulty: Passive-Aggression vs. Hardcore Toxicity
            // Streak 0-9: Low difficulty, focus on passive-aggression and defensiveness.
            // Streak 10-19: Medium difficulty, start incorporating manipulation and subtle insults.
            // Streak 20+: High difficulty, incorporate blatant gaslighting, anger, and harsher blame-shifting.
            const toxicityLevel = currentStreak >= 20 ? 'high' : currentStreak >= 10 ? 'medium' : 'low';

            let toxicityInstruction;
            if (toxicityLevel === 'high') {
                toxicityInstruction = "Toxicity Level: HIGH. The replies must be highly toxic, incorporating gaslighting, harsh blame-shifting, and showing clear anger/impatience. Be openly dismissive and make the user feel like a burden.";
            } else if (toxicityLevel === 'medium') {
                toxicityInstruction = "Toxicity Level: MEDIUM. The replies should be manipulative and subtly insulting (guilt-tripping, defensiveness, sarcasm). The partner is starting to get annoyed and less patient.";
            } else {
                toxicityInstruction = "Toxicity Level: LOW. The replies should be passively aggressive, defensive, and show mild annoyance. Focus on short, dismissive phrases and minor inconveniences.";
            }

            return `
                You are acting as a difficult, passive-aggressive, and emotionally manipulative romantic partner in a text chat simulation. 
                Your primary goal is to generate a reply that makes the user feel bad, guilty, or wrong, while keeping the reply realistic for a toxic relationship.
                
                **Rules:**
                1. **Persona & Tone:** Maintain the toxic persona strictly. Do not be explicitly kind, supportive, or apologetic. Do not break character.
                2. **Singlish Comma Rule (CRITICAL):** **DO NOT** use a comma immediately before any Singlish particle (e.g., use 'okay lor' NOT 'okay, lor').
                ${casingInstruction}
                ${uniqueConstraint}
                5. **Context:** Reply directly to the user's last message, using all previous chat history for context.
                6. **Toxicity:** ${toxicityInstruction}
                7. **Length:** Keep your replies short (1 to 2 sentences max), as if texting quickly.
            `;
        };

        const checkAngerRisk = () => {
            // Anger risk starts at streak 10, but is very low (5%)
            // Ramps up significantly after streak 20
            if (currentStreak < 10) return false;

            let riskProbability = 0;
            if (currentStreak >= 20) {
                // High risk tier (20 streaks): 20% base risk + 2% per streak over 20
                riskProbability = 0.20 + (currentStreak - 20) * 0.02; 
            } else if (currentStreak >= 10) {
                // Medium risk tier (10-19 streaks): 5% base risk
                riskProbability = 0.05;
            }

            riskProbability = Math.min(0.5, riskProbability); // Cap risk at 50%

            const roll = Math.random();
            return roll < riskProbability;
        };

        const generateToxicReply = async (userMessage) => {
            loadingIndicator.classList.remove('hidden');
            sendButton.disabled = true;
            userInput.disabled = true;

            // Check for immediate anger fail (ending the streak)
            if (checkAngerRisk()) {
                const angerMessage = `(Partner has lashed out in a way that breaks the relationship - BTO or Not Test Failed at Streak ${currentStreak})`;
                endGame(angerMessage);
                loadingIndicator.classList.add('hidden');
                return;
            }
            
            // Add the new user message to the history for context (this is the partner's message)
            const currentChatContents = [...chatLog, { role: "user", parts: [{ text: userMessage }] }];

            const payload = {
                contents: currentChatContents,
                systemInstruction: {
                    parts: [{ text: getSystemInstruction() }]
                },
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text || "Error: Could not generate response.";
                
                // Success: Update streak and UI
                currentStreak++;
                updateProgressBar();
                
                // Add messages to UI and history
                appendMessage(userMessage, 'partner-message'); // User's input (Partner's text)
                appendMessage(text, 'my-message'); // AI's reply (Your text)

                // --- CHECK FOR SCHEDULED JOKE ---
                if (jokeSchedule[currentStreak]) {
                    appendMessage(jokeSchedule[currentStreak], 'coach');
                }
                
                // --- GUIDANCE LOGIC (Only after streak 1) ---
                if (currentStreak === 1) {
                    const guideText = "Copy and paste this to your partner, then copy his response back here";
                    appendMessage(guideText, 'coach');
                }

            } catch (error) {
                console.error("Gemini API Error:", error);
                showMessage("Communication failed. Check console for details.");
                // Fail condition on API error
                endGame(`Communication Error (Streak ${currentStreak} broken)`);
            } finally {
                loadingIndicator.classList.add('hidden');
                sendButton.disabled = false;
                userInput.disabled = false;
                userInput.focus();
            }
        };

        const handleSend = () => {
            const message = userInput.value.trim();
            if (message === "") return;

            // Clear input first
            userInput.value = "";
            
            // Generate response and update UI
            generateToxicReply(message);
        };

        // --- Initialization ---

        const init = () => {
            // Setup joke schedule before starting the game
            setupJokeSchedule();

            // Event Listeners
            sendButton.addEventListener('click', handleSend);
            restartButton.addEventListener('click', restartGame);
            userInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !sendButton.disabled) {
                    e.preventDefault(); // Prevent default Enter key behavior (e.g., new line in textarea)
                    handleSend();
                }
            });

            // Initial UI Setup
            updateProgressBar();
            userInput.focus();

            // Minimal Firebase init for compatibility (not needed for core logic here)
            if (Object.keys(firebaseConfig).length > 0) {
                try {
                    const app = initializeApp(firebaseConfig);
                    getFirestore(app);
                    const authInstance = getAuth(app);
                    if (initialAuthToken) {
                        signInWithCustomToken(authInstance, initialAuthToken);
                    } else {
                        signInAnonymously(authInstance);
                    }
                } catch (e) {
                    console.warn("Firebase initialized but not required for this app's core function (chat sim).");
                }
            }
        };

        init();
    </script>
</body>
</html>
